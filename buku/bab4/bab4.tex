\chapter{IMPLEMENTASI} \label{chap:implementasi}

\tab Pada bab ini akan dijelaskan mengenai implementasi dari perancangan struktur data dan algoritme untuk menyelesaikan permasalahan \problemDua{} sebagaimana yang telah dijelaskan pada Bab \ref{chap:analisis-perancangan-sistem}. Penjelasan implementasi terdiri dari penjelasan kelas dan fungsi yang dibuat, disertai dengan \textit{pseudocode} untuk masing-masing fungsi tersebut.

\section{Lingkungan Implementasi}
\tab Lingkungan implementasi dalam pembuatan Tugas Akhir ini meliputi perangkat keras dan perangkat lunak dengan spesifikasi sebagai berikut:

\begin{enumerate}
	\item Perangkat Keras:
		\begin{itemize}
			\item Prosesor 2.6 GHz Intel Core i5 (I5-4278U)
			\item Memori 8 GB 1600 MHz DDR3
		\end{itemize}
	\item Perangkat Lunak:
	\begin{itemize}
		\item Sistem operasi macOS Mojave Versi 10.14.5
		\item \textit{Text editor} Visual Studio Code Versi 1.33.1
		\item Bahasa Pemrograman Python 3.7.3
		\item Flask \textit{Microframework} 1.0.2
	\end{itemize}			
\end{enumerate}

\section{Implementasi \textit{Data Precomputing}}
\tab \textit{Data precomputing} merupakan pemrosesan tahap pertama dalam algoritme $k$-MPPTI yang bertujuan untuk mengolah \textit{dataset} produk $P$ dan preferensi pelanggan $C$ dengan jumlah data sebanyak $n$ dan ukuran dimensi sebesar $d$, menjadi sebuah $Pandora Box$ yang menyimpan skor kontribusi pasar semua produk pada setiap waktu. Algoritme ini diimplementasikan menggunakan paradigma pemrograman berorientasi objek, sehingga semua data dan fungsi dibungkus dalam kelas-kelas. Ada empat macam kelas yang diimplementasikan, yaitu kelas \textit{EventQueue}, \textit{PandoraBox}, \textit{ReverseSkyline}, dan \textit{DynamicSkyline}.

\subsection{Kelas \textit{EventQueue}}
\tab Kelas \textit{EventQueue} mendefinisikan bentuk dan perilaku dari objek \textit{Event Queue} yang berfungsi untuk menyimpan \textit{event-event} yang terjadi di dalam himpunan data. Kelas ini mengimplementasikan karakteristik dari struktur data \textit{queue}, yakni FIFO (\textit{First In First Out}).

\begin{figure}[H]
	\begin{algorithm}[H]
		\label{algo:event-queue-class}
		\caption{EventQueue}
		\begin{algorithmic}[1]
			\Statex \textbf{Input \hskip1em :} timestamp $t$, event's owner $o$ (product/customer), owner ID $oid$, action $a$ (insertion/deletion)
			\Statex
			\State $E \leftarrow$ empty list \Comment{Initialization}
			\Procedure{\large{E}\small{NQUEUE}}{$t$, $o$, $oid$, $a$}
				\State $e \leftarrow$ list($t, o, oid, a$)
				\State $E \leftarrow$ append $e$ 
			\EndProcedure
			\Procedure{\large{D}\small{EQUEUE}}{}
				\State $e \leftarrow$ pop an element from $E$
				\State \Return $e$
			\EndProcedure
			\Procedure{\large{S}\small{ORT}\large{Q}\small{UEUE}}{}
				\State $E \leftarrow$ sort elements in descending order based on sorting priority
			\EndProcedure
			\Procedure{\large{G}\small{ET}\large{T}\small{OTAL}\large{Q}\small{UEUE}}{}
				\State \Return number of elements in $E$
			\EndProcedure
			\Procedure{\large{G}\small{ET}\large{M}\small{AX}\large{T}\small{IMESTAMP}}{}
				\State \Return first index of $E$
			\EndProcedure
		\end{algorithmic}
	\end{algorithm}
	\caption{Kelas \textit{EventQueue}}
\end{figure}

\begin{figure}[H]
	\begin{algorithm}[H]
		\label{algo:event-queue-instance}
		\caption{StoreEventQueue}
		\begin{algorithmic}[1]
			\Statex \textbf{Input \hskip1em :} product dataset $P$, customer dataset $C$ 
			\Statex \textbf{Output \hskip0.3em :} an instance of EventQueue class
			\Statex
			\State $EQ \leftarrow$ EventQueue object instantiation
			\For 
			
		\end{algorithmic}
	\end{algorithm}
	\caption{Objek \textit{EventQueue}}
\end{figure}
  

\section{Implementasi Algoritme \textit{Query Processing}}
\section{Implementasi Algoritme \textit{Brute Force}}
\section{Implementasi Antarmuka Pengguna}
